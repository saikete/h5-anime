import {
  Transition,
  callWithAsyncErrorHandling,
  cloneVNode,
  createVNode,
  defineComponent,
  getCurrentInstance,
  isVNode,
  onUnmounted,
  queuePostFlushCb
} from "./chunk-Z35YBE6Z.js";

// node_modules/page-stack-vue3/es/componentCache.js
var FLAG_NEED_KEEP_ALIVE = 1 << 8;
var FLAG_KEPT_ALIVE = 1 << 9;
var statusMap = /* @__PURE__ */ new WeakMap();
var KEY_EL_STATUS = "___ps_s_s";
function saveStatus(node) {
  var _a, _b;
  const el = node.el;
  if (!el || el.nodeType !== 1) {
    return;
  }
  statusMap.set(el, {
    scrollTop: (_a = document.scrollingElement) === null || _a === void 0 ? void 0 : _a.scrollTop,
    scrollLeft: (_b = document.scrollingElement) === null || _b === void 0 ? void 0 : _b.scrollLeft
  });
  saveStatusEl(el);
}
function saveStatusEl(el) {
  if (!el || el.nodeType !== 1) {
    return;
  }
  const status = {
    scrollTop: el.scrollTop,
    scrollLeft: el.scrollLeft
  };
  el[KEY_EL_STATUS] = status;
  for (let i = 0; i < el.childElementCount; i++) {
    saveStatusEl(el.children[i]);
  }
}
function restoreStatus(node) {
  const el = node.el;
  if (!el || el.nodeType !== 1) {
    return;
  }
  restoreStatusEl(el);
  const status = statusMap.get(el);
  if (document.scrollingElement) {
    Object.entries(status || {}).forEach(([key, val]) => {
      document.scrollingElement[key] = val;
    });
  }
}
function restoreStatusEl(el) {
  if (!el || el.nodeType !== 1) {
    return;
  }
  for (let i = 0; i < el.childElementCount; i++) {
    restoreStatusEl(el.children[i]);
  }
  const status = el[KEY_EL_STATUS];
  if (!status) {
    return;
  }
  Object.entries(status).forEach(([key, val]) => {
    el[key] = val;
  });
}
function delStatus(node) {
  statusMap.delete(node.el);
}
var invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
var Props = {
  beforePause: {
    type: Function,
    require: false
  },
  onPause: {
    type: Function,
    require: false
  },
  onResume: {
    type: Function,
    require: false
  },
  beforeResume: {
    type: Function,
    require: false
  },
  saveStatus: {
    type: Boolean,
    default: true
  }
};
function cacheableNode(node) {
  if (!node) {
    return false;
  }
  if (!(node === null || node === void 0 ? void 0 : node.type)) {
    return false;
  }
  if (typeof node.type === "string") {
    return false;
  }
  if (typeof node.type === "symbol") {
    return false;
  }
  return true;
}
var componentCache_default = defineComponent({
  __isKeepAlive: true,
  props: Object.assign(Object.assign({}, Props), {
    componentEvaluator: {
      type: Object,
      default: function() {
        return {
          evaluate(node) {
            return node;
          },
          reset() {
          },
          updateVNode() {
          },
          onRenderVNode(slot) {
            return slot()[0];
          }
        };
      }
    }
  }),
  setup(props, ctx) {
    const beforeDeactive = function(node) {
      if (props.beforePause) {
        props.beforePause(node);
      }
      if (props.saveStatus) {
        saveStatus(node);
      }
    };
    const afterDeactive = function(node) {
      if (props.onPause) {
        props.onPause(node);
      }
    };
    const beforeReactive = function(node) {
      if (props.beforeResume) {
        props.beforeResume(node);
      }
    };
    const afterReactive = function(node) {
      if (props.saveStatus) {
        restoreStatus(node);
      }
      if (props.onResume) {
        props.onResume(node);
      }
    };
    const instance = getCurrentInstance();
    if (!instance) {
      throw new Error("getCurrentInstance return null");
    }
    const {
      suspense: parentSuspense,
      proxy: instanceProxy
    } = instance;
    const renderer = instanceProxy === null || instanceProxy === void 0 ? void 0 : instanceProxy.renderer;
    const {
      p: patch,
      m: move,
      um: _unmount,
      o: {
        createElement
      }
    } = renderer;
    if (!instanceProxy) {
      throw new Error("getCurrentInstance().proxy return null");
    }
    const storageContainer = createElement("div");
    const vnodeActive = function(vnode, container, anchor, isSVG, optimized) {
      const instance2 = vnode.component;
      beforeReactive(vnode);
      move(vnode, container, anchor, 0, parentSuspense);
      queuePostFlushCb(() => {
        instance2.isDeactivated = false;
        const activeFn = instance2.a;
        if (activeFn) {
          invokeArrayFns(activeFn);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          callWithAsyncErrorHandling(vnodeHook, instance2.parent, 7, [vnode, null]);
        }
      });
      queuePostFlushCb(function() {
        afterReactive(vnode);
      });
      patch(instance2.vnode, vnode, container, anchor, instance2, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
    };
    const vnodeDeactive = function(vnode) {
      const instance2 = vnode.component;
      beforeDeactive(vnode);
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostFlushCb(() => {
        const deactiveFn = instance2.da;
        if (deactiveFn) {
          invokeArrayFns(deactiveFn);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          callWithAsyncErrorHandling(vnodeHook, instance2.parent, 7, [vnode, null]);
        }
        instance2.isDeactivated = true;
      });
      afterDeactive(vnode);
    };
    instanceProxy.activate = vnodeActive;
    instanceProxy.deactivate = vnodeDeactive;
    const uncacheNode = function(node) {
      node.shapeFlag &= ~FLAG_KEPT_ALIVE;
      node.shapeFlag &= ~FLAG_NEED_KEEP_ALIVE;
    };
    const destory = function(node) {
      delStatus(node);
      uncacheNode(node);
      _unmount(node, instance, parentSuspense, true);
    };
    const cacheNode = function(node) {
      node.shapeFlag |= FLAG_NEED_KEEP_ALIVE;
      return node;
    };
    const reuseNode = function(node, reuseNode2) {
      if (!reuseNode2.component) {
        return null;
      }
      const retNode = node;
      retNode.el = reuseNode2.el;
      retNode.component = reuseNode2.component;
      retNode.shapeFlag |= FLAG_KEPT_ALIVE;
      retNode.shapeFlag |= FLAG_NEED_KEEP_ALIVE;
      return retNode;
    };
    const cacheContext = {
      cacheNode,
      reuseNode,
      uncacheNode,
      cacheable: cacheableNode,
      destory
    };
    onUnmounted(function() {
      props.componentEvaluator.reset(cacheContext);
    });
    return function() {
      var _a, _b, _c, _d;
      const evaluator = props.componentEvaluator;
      let newComponent = evaluator.onRenderVNode((_a = ctx.slots) === null || _a === void 0 ? void 0 : _a.default);
      if (!newComponent) {
        return newComponent;
      }
      const originChild = newComponent;
      let shouldOrvewriteChild = false;
      if ((_b = newComponent.type.displayName) === null || _b === void 0 ? void 0 : _b.includes("Transition")) {
        const tarnsitionChildSlots = newComponent.children;
        if (!tarnsitionChildSlots) {
          return tarnsitionChildSlots;
        }
        if (isVNode(tarnsitionChildSlots)) {
          newComponent = tarnsitionChildSlots;
          shouldOrvewriteChild = true;
        } else if (Array.isArray(tarnsitionChildSlots)) {
          throw new Error("cannot has array child");
        } else if (typeof tarnsitionChildSlots === "object") {
          newComponent = ((_d = (_c = tarnsitionChildSlots).default) === null || _d === void 0 ? void 0 : _d.call(_c)[0]) || null;
          shouldOrvewriteChild = true;
          if (!newComponent) {
            return originChild;
          }
        } else {
          return originChild;
        }
      }
      let displayComponent = evaluator.evaluate(newComponent, cacheContext);
      if (!displayComponent) {
        return displayComponent;
      }
      if (shouldOrvewriteChild && originChild) {
        const userVNode = displayComponent;
        const child = cloneVNode(displayComponent, {
          onVnodeBeforeMount(vnode) {
            var _a2, _b2;
            evaluator.updateVNode(userVNode, vnode);
            const ctx2 = (_b2 = (_a2 = vnode === null || vnode === void 0 ? void 0 : vnode.component) === null || _a2 === void 0 ? void 0 : _a2.parent) === null || _b2 === void 0 ? void 0 : _b2.ctx;
            if (ctx2) {
              if (!ctx2.deactivate) {
                ctx2.deactivate = vnodeDeactive;
              }
              if (!ctx2.activate) {
                ctx2.activate = vnodeActive;
              }
            }
          }
        });
        originChild.children = {
          default: () => child
        };
        originChild["__isKeepAlive"] = true;
        displayComponent = originChild;
        child.patchFlag |= userVNode.patchFlag;
        uncacheNode(userVNode);
        cacheNode(displayComponent);
      }
      return displayComponent;
    };
  }
});

// node_modules/page-stack-vue3/es/pageStack.js
var PageNode = class {
  constructor(node, lifecycleCallback, tag) {
    this.node = node || null;
    this.tag = tag || null;
    this.lifecycleCallback = lifecycleCallback || null;
    this.next = null;
    this.pre = null;
    this.state = null;
    this.lifeState = null;
  }
  moveTo(life, async = false) {
    var _a;
    if (!life || this.lifeState === life || !this.node || !this.lifecycleCallback) {
      return;
    }
    this.lifeState = life;
    const {
      node,
      lifecycleCallback
    } = this;
    if (async) {
      queuePostFlushCb(() => {
        var _a2;
        (_a2 = lifecycleCallback[life]) === null || _a2 === void 0 ? void 0 : _a2.call(lifecycleCallback, node);
      });
    } else {
      (_a = lifecycleCallback[life]) === null || _a === void 0 ? void 0 : _a.call(lifecycleCallback, node);
    }
  }
  updateState(state) {
    state.curNode = this.tag;
    this.state = state;
  }
};
function same(n1, n2) {
  if (n1 === n2) {
    return true;
  }
  return n1.type === n2.type;
}
var PageStack = class {
  constructor(lifecycleCallback, router, mergeQueryToProps = false) {
    this.idGen = new Date().valueOf();
    this.pageList = new PageNode();
    this.lastDisplayPage = null;
    this.mergeQueryToProps = false;
    this.lifecycleCallback = lifecycleCallback || null;
    this.router = router || null;
    this.mergeQueryToProps = mergeQueryToProps;
  }
  getLastPageNode(subPage) {
    let tail = subPage || this.pageList;
    while (tail.next) {
      tail = tail.next;
    }
    return tail;
  }
  findPageNode(tag) {
    let cur = this.pageList.next;
    while (cur && cur.tag !== tag) {
      cur = cur.next;
    }
    return cur;
  }
  createPage(node, state, link = true) {
    var _a, _b;
    const tag = String(this.idGen++);
    const pn = new PageNode(cloneVNode(node, {
      key: (((_b = (_a = node.props) === null || _a === void 0 ? void 0 : _a.key) === null || _b === void 0 ? void 0 : _b.toString()) || "") + tag
    }), this.lifecycleCallback || void 0, tag);
    if (link) {
      const lp = this.getLastPageNode();
      lp.next = pn;
      pn.pre = lp;
    }
    state.curNode = tag;
    pn.state = state;
    pn.moveTo("onCreate");
    pn.moveTo("onResume", true);
    return pn;
  }
  copyKeyProps(page, newNode) {
    return cloneVNode(newNode, {
      key: page.node.key
    });
  }
  iterPage(start, callback, reverse = false) {
    let cur = start || this.pageList.next;
    if (!cur) {
      return;
    }
    if (reverse) {
      cur = this.getLastPageNode(cur);
      while (cur && cur !== this.pageList) {
        callback(cur);
        cur = cur.pre;
      }
      return;
    }
    while (cur) {
      callback(cur);
      cur = cur.next;
    }
  }
  destoryPage(fromPage, ctx) {
    if (!fromPage || fromPage === this.pageList) {
      return;
    }
    this.iterPage(fromPage, (p) => {
      if (p.node) {
        p.moveTo("beforeDestory");
        ctx.destory(p.node);
        p.moveTo("onDestory");
      }
    }, true);
    if (!fromPage.pre) {
      return;
    }
    fromPage.pre.next = null;
  }
  destoryPageAsync(ctx, page) {
    if (!page) {
      return;
    }
    queuePostFlushCb(() => {
      this.destoryPage(page, ctx);
    });
  }
  debugPageStack(msg) {
  }
  updateVNode(oldNode, newNode) {
    this.iterPage(null, function(p) {
      if (p.node === oldNode) {
        p.node = newNode;
      }
    });
  }
  size() {
    let count = 0;
    this.iterPage(null, function() {
      count++;
    });
    return count;
  }
  removeNode(page) {
    if (!page) {
      return page;
    }
    if (page.pre) {
      page.pre.next = null;
    }
    page.pre = null;
    return page;
  }
  evaluate(node, ctx) {
    this.debugPageStack("before");
    const n = this._evaluate(node, ctx);
    this.debugPageStack("after evaluate");
    setTimeout(() => {
      this.debugPageStack("post evaluate");
    }, 0);
    return n;
  }
  setRouteProps(node) {
    var _a;
    const query = (_a = this.router) === null || _a === void 0 ? void 0 : _a.currentRoute.value.query;
    if (!this.mergeQueryToProps || !query) {
      return node;
    }
    return cloneVNode(node, Object.assign({}, query));
  }
  getAction() {
    const state = history.state;
    if (!state || typeof state !== "object" || !Reflect.has(state, "position")) {
      return "unknown";
    }
    if (!this.lastDisplayPage) {
      return "init";
    }
    if (!this.lastDisplayPage.state) {
      return "unknown";
    }
    const {
      position: targetPosition
    } = state;
    const {
      position: curPosition
    } = this.lastDisplayPage.state;
    if (targetPosition > curPosition) {
      return "forword";
    }
    if (targetPosition < curPosition) {
      return "back";
    }
    return "replace";
  }
  onRenderVNode(slot) {
    var _a;
    const action = this.getAction();
    return (_a = slot({
      action
    })) === null || _a === void 0 ? void 0 : _a[0];
  }
  _evaluate(n, ctx) {
    if (!ctx.cacheable(n)) {
      return n;
    }
    const node = this.setRouteProps(n);
    const state = history.state;
    if (!state || typeof state !== "object" || !Reflect.has(state, "position")) {
      return n;
    }
    const action = this.getAction();
    if (this.lastDisplayPage && this.lastDisplayPage.state) {
      const {
        curNode
      } = state;
      if (action === "forword") {
        this.lastDisplayPage.moveTo("onPause");
        const pn = this.createPage(node, state);
        this.lastDisplayPage = pn;
        ctx.cacheNode(pn.node);
        return pn.node;
      }
      const oldPage = this.findPageNode(curNode);
      if (action === "back" && oldPage && oldPage.node && same(oldPage.node, node)) {
        const oldNode = oldPage.node;
        oldPage.node = ctx.reuseNode(this.copyKeyProps(oldPage, node), oldPage.node);
        if (oldPage.node) {
          const dp = this.removeNode(oldPage.next);
          this.destoryPageAsync(ctx, dp);
          this.lastDisplayPage = oldPage;
          oldPage.updateState(state);
          oldPage.moveTo("onResume", true);
          return oldPage.node;
        }
        oldPage.node = oldNode;
      }
      if (action === "replace") {
        const oldPage2 = this.findPageNode(this.lastDisplayPage.tag);
        if (oldPage2 && oldPage2.node && same(oldPage2.node, node)) {
          const oldNode = oldPage2.node;
          oldPage2.node = ctx.reuseNode(this.copyKeyProps(oldPage2, node), oldPage2.node);
          if (oldPage2.node) {
            const dp2 = this.removeNode(oldPage2.next);
            this.destoryPageAsync(ctx, dp2);
            this.lastDisplayPage = oldPage2;
            oldPage2.updateState(state);
            oldPage2.moveTo("onResume", true);
            return oldPage2.node;
          }
          oldPage2.node = oldNode;
          const dp = this.removeNode(oldPage2);
          this.destoryPageAsync(ctx, dp);
          this.lastDisplayPage = this.createPage(node, state);
          this.lastDisplayPage.node = ctx.cacheNode(this.lastDisplayPage.node);
          return this.lastDisplayPage.node;
        }
        this.destoryPageAsync(ctx, this.removeNode(this.lastDisplayPage));
        this.lastDisplayPage = this.createPage(node, state);
        ctx.cacheNode(this.lastDisplayPage.node);
        return this.lastDisplayPage.node;
      }
    }
    const destoryPage = this.removeNode(this.pageList.next);
    this.destoryPageAsync(ctx, destoryPage);
    this.pageList.next = this.createPage(node, state);
    ctx.cacheNode(this.pageList.next.node);
    this.lastDisplayPage = this.pageList.next;
    return this.lastDisplayPage.node;
  }
  reset(ctx) {
    this.onReset(ctx);
    this.lastDisplayPage = null;
    this.destoryPage(this.pageList, ctx);
  }
  onReset(ctx) {
  }
};

// node_modules/page-stack-vue3/es/index.js
import "/Users/yanganxu/Documents/my-project/h5-anime/node_modules/page-stack-vue3/es/index.css";
var TRANSITION_NAME_IN = "ps-slide-in";
var TRANSITION_NAME_OUT = "ps-slide-out";
var es_default = defineComponent({
  props: Object.assign(Object.assign({}, Props), {
    lifeCycleCallback: {
      type: Object,
      require: false
    },
    router: {
      type: Object,
      require: false
    },
    mergeQueryToProps: {
      type: Boolean,
      default: false
    },
    disableAnimation: {
      type: Boolean,
      default: false
    }
  }),
  setup(props, ctx) {
    const evaluator = new PageStack(props.lifeCycleCallback, props.router, props.mergeQueryToProps);
    ctx.expose({
      getPageSize: evaluator.size.bind(evaluator)
    });
    return function() {
      return createVNode(componentCache_default, {
        "componentEvaluator": evaluator
      }, {
        default: function(data) {
          var _a, _b, _c, _d, _e, _f;
          if (props.disableAnimation) {
            return (_c = (_b = (_a = ctx.slots).default) === null || _b === void 0 ? void 0 : _b.call(_a, data)) === null || _c === void 0 ? void 0 : _c[0];
          }
          let transName = "";
          if (data.action === "back") {
            transName = TRANSITION_NAME_OUT;
          } else if (data.action === "forword") {
            transName = TRANSITION_NAME_IN;
          }
          return createVNode(Transition, {
            "name": transName
          }, {
            default: () => [(_f = (_e = (_d = ctx.slots).default) === null || _e === void 0 ? void 0 : _e.call(_d, data)) === null || _f === void 0 ? void 0 : _f[0]]
          });
        }
      });
    };
  }
});

// dep:page-stack-vue3
var page_stack_vue3_default = es_default;
export {
  Props,
  page_stack_vue3_default as default,
  invokeArrayFns
};
//# sourceMappingURL=page-stack-vue3.js.map
